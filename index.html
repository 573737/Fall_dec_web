<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Real-Time Sensor Data with Predictions</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #f0f0f0;
      font-family: Arial, sans-serif;
    }
    #sensorOutput {
      text-align: center;
      border: 1px solid #ccc;
      padding: 20px;
      background-color: white;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: center;
    }
    th {
      background-color: #f2f2f2;
    }
  </style>
</head>
<body>
  <div id="sensorOutput">
    <h2>Sensor Data Table with Predictions</h2>
    <table id="sensorTable">
      <thead>
        <tr>
          <th>Time</th>
          <th>Acc_X</th>
          <th>Acc_Y</th>
          <th>Acc_Z</th>
          <th>Gyr_X</th>
          <th>Gyr_Y</th>
          <th>Gyr_Z</th>
          <th>Mag_X</th>
          <th>Mag_Y</th>
          <th>Mag_Z</th>
          <th>Ori_Alpha</th>
          <th>Ori_Beta</th>
          <th>Ori_Gamma</th>
          <th>Vel_X</th>
          <th>Vel_Y</th>
          <th>Vel_Z</th>
          <th>Prediction</th>
        </tr>
      </thead>
      <tbody>
        <!-- Rows will be dynamically inserted here -->
      </tbody>
    </table>
  </div>

  <script>
    let model;
    (async () => {
      try {
        model = await tf.loadGraphModel('./model.json');
      } catch (error) {
        console.error("Error loading model:", error);
      }
    })();

    const sensorTableBody = document.querySelector("#sensorTable tbody");

    // Initialize velocity and previous timestamp
    let velocity = { x: 0, y: 0, z: 0 };
    let lastTimestamp = null;

    // Helper function to normalize sensor data with error handling
    function normalize(value, min, max) {
      if (value === undefined || min >= max) {
        return 0; // Handle cases where normalization may fail
      }
      return (value - min) / (max - min);
    }

    function handleDeviceMotion(event) {
      const { acceleration, rotationRate, timeStamp } = event;

      if (acceleration) {
        if (lastTimestamp !== null) {
          const dt = (timeStamp - lastTimestamp) / 1000; // Convert to seconds
          velocity.x += (acceleration.x ?? 0) * dt;
          velocity.y += (acceleration.y ?? 0) * dt;
          velocity.z += (acceleration.z ?? 0) * dt;
        }

        lastTimestamp = timeStamp;

        // Update table with acceleration and velocity data
        const newRow = document.createElement("tr");
        const currentTime = new Date().toLocaleTimeString();

        const expectedRanges = {
          acceleration: { min: -10, max: 10 },
          gyroscope: { min: -250, max: 250 },
          magnetometer: { min: -100, max: 100 },
        };

        const normalizedAcceleration = {
          x: normalize(acceleration.x, expectedRanges.acceleration.min, expectedRanges.acceleration.max),
          y: normalize(acceleration.y, expectedRanges.acceleration.min, expectedRanges.acceleration.max),
          z: normalize(acceleration.z, expectedRanges.acceleration.min, expectedRanges.acceleration.max),
        };

        const normalizedVelocity = {
          x: normalize(velocity.x, expectedRanges.acceleration.min, expectedRanges.acceleration.max),
          y: normalize(velocity.y, expectedRanges.acceleration.min, expectedRanges.acceleration.max),
          z: normalize(velocity.z, expectedRanges.acceleration.min, expectedRanges.acceleration.max),
        };

        newRow.innerHTML = `
          <td>${currentTime}</td>
          <td>${normalizedAcceleration.x.toFixed(2)}</td>
          <td>${normalizedAcceleration.y.toFixed(2)}</td>
          <td>${normalizedAcceleration.z.toFixed(2)}</td>
          <td>${(rotationRate.alpha ?? 'N/A').toFixed(2)}</td>
          <td>${(rotationRate.beta ?? 'N/A').toFixed(2)}</td>
          <td>${(rotationRate.gamma ?? 'N/A').toFixed(2)}</td>
          <td>N/A</td> <!-- Magnetometer data can be added here -->
          <td>N/A</td>
          <td>N/A</td>
          <td>N/A</td> <!-- Orientation data will be handled in the orientation event -->
          <td>N/A</td>
          <td>N/A</td>
          <td>${normalizedVelocity.x.toFixed(2)}</td>
          <td>${normalizedVelocity.y.toFixed(2)}</td>
          <td>${normalizedVelocity.z.toFixed(2)}</td>
          <td>N/A</td> <!-- Prediction will be handled separately -->
        `;

        sensorTableBody.appendChild(newRow);
      }
    }

    window.addEventListener("devicemotion", handleDeviceMotion);

    function handleDeviceOrientation(event) {
      const { alpha, beta, gamma } = event;

      const lastRow = sensorTableBody.lastElementChild;

      if (lastRow) {
        lastRow.children[11].textContent = (alpha ?? 'N/A').toFixed(2); // Ori_Alpha
        lastRow.children[12].textContent = (beta ?? 'N/A').toFixed(2); // Ori_Beta
        lastRow.children[13].textContent = (gamma ?? 'N/A').toFixed(2); // Ori_Gamma
      }
    }

    window.addEventListener("deviceorientation", handleDeviceOrientation);

    async function makePrediction() {
      if (model) {
        try {
          const lastRow = sensorTableBody.lastElementChild;

          if (lastRow) {
            const sensorData = [];
            for (let i = 1; i <= 16; i++) {
              const value = parseFloat(lastRow.children[i].textContent);
              sensorData.push(isNaN(value) ? 0 : value); // Ensure valid sensor data
            }

            const inputTensor = tf.tensor2d([sensorData], [1, 16], 'float32');
            const prediction = model.predict(inputTensor); // Predict using TensorFlow.js
            const predictedValue = (await prediction.data())[0].toFixed(2);

            lastRow.children[17].textContent = predictedValue; // Display prediction
            inputTensor.dispose(); // Dispose of tensor
          }
        } catch (error) {
          console.error("Error during prediction:", error);
        }
      } else {
        console.warn("Model not loaded");
      }
    }

    setInterval(makePrediction, 3000); // Trigger prediction every 3 seconds
  </script>
</body>
</html>
