<!DOCTYPE html>
<html lang="en">

<head>
  <title>Sensor Data with Dynamic Readings and TensorFlow Prediction</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script> <!-- Load TensorFlow.js -->
</head>

<body>
  <h1>Sensor Data with Dynamic Updates</h1>

  <!-- Display sensor data -->
  <div>
    <h2>Velocity</h2>
    <p>X: <span id="vel-x">0</span></p>
    <p>Y: <span id="vel-y">0</span></p>
    <p>Z: <span id="vel-z">0</span></p>
  </div>

  <div>
    <h2>Accelerometer</h2>
    <p>X: <span id="acc-x">0</span></p>
    <p>Y: <span id="acc-y">0</span></p>
    <p>Z: <span id="acc-z">0</span></p>
  </div>

  <div>
    <h2>Gyroscope</h2>
    <p>Alpha: <span id="gyr-x">0</span></p>
    <p>Beta: <span id="gyr-y">0</span></p>
    <p>Gamma: <span id="gyr-z">0</span></p>
  </div>

  <div>
    <h2>Orientation</h2>
    <p>Alpha: <span id="ori-w">0</span></p>
    <p>Beta: <span id="ori-x">0</span></p>
    <p>Gamma: <span id="ori-y">0</span></p>
  </div>

  <div>
    <h2>Magnetometer (Derived)</h2>
    <p>X: <span id="mag-x">0</span></p>
    <p>Y: <span id="mag-y">0</span></p>
    <p>Z: <span id="mag-z">0</span></p>
  </div>

  <div>
    <h2>Prediction Result</h2>
    <p>Prediction: <span id="prediction-result">N/A</span></p>
  </div>

  <script>
    // TensorFlow.js model
    let model;
    (async () => {
      try {
        model = await tf.loadGraphModel('./model.json'); // Load TensorFlow.js model
      } catch (error) {
        console.error("Error loading TensorFlow.js model:", error);
      }
    })();

    // Initialize sensor data
    let velX = 0, velY = 0, velZ = 0;
    let lastTimestamp = null;

    // Normalization helper function
    function normalize(value, min, max) {
      return (value - min) / (max - min);
    }

    // Set up sensor data
    let acceleration = { x: 0, y: 0, z: 0 };
    let gyroscope = { x: 0, y: 0, z: 0 };
    let orientation = { alpha: 0, beta: 0, gamma: 0 };
    let derivedMagnetometer = { x: 0, y: 0, z: 0 }; // Placeholder for derived magnetometer

    // Device Motion Event
    if (window.DeviceMotionEvent) {
      window.addEventListener('devicemotion', function (event) {
        const { acceleration: acc, rotationRate, timeStamp } = event;

        if (lastTimestamp !== null) {
          const dt = (timeStamp - lastTimestamp) / 1000;

          velX += (acc.x ?? 0) * dt;
          velY += (acc.y ?? 0) * dt;
          velZ += (acc.z ?? 0) * dt;
        }

        lastTimestamp = timeStamp;

        acceleration.x = acc.x ?? 0;
        acceleration.y = acc.y ?? 0;
        acceleration.z = acc.z ?? 0;

        gyroscope.x = rotationRate?.alpha ?? 0;
        gyroscope.y = rotationRate?.beta ?? 0;
        gyroscope.z = rotationRate?.gamma ?? 0;

        // Update sensor data in real-time
        document.getElementById("vel-x").innerText = velX.toFixed(2);
        document.getElementById("vel-y").innerText = velY.toFixed(2);
        document.getElementById("vel-z").innerText = velZ.toFixed(2);

        document.getElementById("acc-x").innerText = acceleration.x.toFixed(2);
        document.getElementById("acc-y").innerText = acceleration.y.toFixed(2);
        document.getElementById("acc-z").innerText = acceleration.z.toFixed(2);

        document.getElementById("gyr-x").innerText = gyroscope.x.toFixed(2);
        document.getElementById("gyr-y").innerText = gyroscope.y.toFixed(2);
        document.getElementById("gyr-z").innerText = gyroscope.z.toFixed(2);
      });
    }

    // Device Orientation Event
    if (window.DeviceOrientationEvent) {
      window.addEventListener('deviceorientation', function (event) {
        orientation.alpha = event.alpha ?? 0;
        orientation.beta = event.beta ?? 0;
        orientation.gamma ?? 0;

        // Update orientation data
        document.getElementById("ori-w").innerText = orientation.alpha.toFixed(2);
        document.getElementById("ori-x").innerText = orientation.beta.toFixed(2);
        document.getElementById("ori-y").innerText = orientation.gamma.toFixed(2);
      });
    }

    // Derive magnetometer data based on orientation and other sensors
    function deriveMagnetometer() {
      // Example approximation: simple mapping of orientation to a "magnetic" value
      derivedMagnetometer.x = Math.sin((orientation.alpha || 0) * Math.PI / 180);
      derivedMagnetometer.y = Math.cos((orientation.beta || 0) * Math.PI / 180);
      derivedMagnetometer.z = Math.sin((orientation.gamma || 0) * Math.PI / 180);

      // Update derived magnetometer data
      document.getElementById("mag-x").innerText = derivedMagnetometer.x.toFixed(2);
      document.getElementById("mag-y").innerText = derivedMagnetometer.y.toFixed(2);
      document.getElementById("mag-z").innerText = derivedMagnetometer.z.toFixed(2);
    }

    // Function to get normalized data and predict
    async function predictWithNormalizedData() {
      // Normalize sensor data
      const expectedRanges = {
        velocity: { min: -10, max: 10 },
        orientation: { min: 0, max: 360 },
        acceleration: { min: -10, max: 10 },
        gyroscope: { min: -250, max: 250 },
        magnetometer: { min: -1, max: 1 },
      };

      const normalizedVelocity = {
        x: normalize(velX, expectedRanges.velocity.min, expectedRanges.velocity.max),
        y: normalize(velY, expectedRanges.velocity.min, expectedRanges.velocity.max),
        z: normalize(velZ, expectedRanges.velocity.min, expectedRanges.velocity.max),
      };

      const normalizedOrientation = {
        w: normalize(orientation.alpha, expectedRanges.orientation.min, expectedRanges.orientation.max),
        x: normalize(orientation.beta, expectedRanges.orientation.min, expectedRanges.orientation.max),
        y: normalize(orientation.gamma, expectedRanges.orientation.min, expectedRanges.orientation.max),
        z: normalize(orientation.alpha, expectedRanges.orientation.min, expectedRanges.orientation.max),
      };

      const normalizedAcceleration = {
        x: normalize(acceleration.x, expectedRanges.acceleration.min, expectedRanges.acceleration.max),
        y: normalize(acceleration.y, expectedRanges.acceleration.min, expectedRanges.acceleration.max),
        z: normalize(acceleration.z, expectedRanges.acceleration.min, expectedRanges.acceleration.max),
      };

      const normalizedGyroscope = {
        x: normalize(gyroscope.x, expectedRanges.gyroscope.min, expectedRanges.gyroscope.max),
        y: normalize(gyroscope.y, expectedRanges.gyroscope.min, expectedRanges.gyroscope.max),
        z: normalize(gyroscope.z, expectedRanges.gyroscope.min, expectedRanges.gyroscope.max),
      };

      deriveMagnetometer(); // Update derived magnetometer values

      const normalizedMagnetometer = {
        x: normalize(derivedMagnetometer.x, expectedRanges.magnetometer.min, expectedRanges.magnetometer.max),
        y: normalize(derivedMagnetometer.y, expectedRanges.magnetometer.min, expectedRanges.magnetometer.max),
        z: normalize(derivedMagnetometer.z, expectedRanges.magnetometer.min, expectedRanges.magnetometer.max),
      };

      const predictionInput = [
        normalizedVelocity.x,
        normalizedVelocity.y,
        normalizedVelocity.z,
        normalizedOrientation.w,
        normalizedOrientation.x,
        normalizedOrientation.y,
        normalizedOrientation.z,
        normalizedAcceleration.x,
        normalizedAcceleration.y,
        normalizedAcceleration.z,
        normalizedGyroscope.x,
        normalizedGyroscope.y,
        normalizedGyroscope.z,
        normalizedMagnetometer.x,
        normalizedMagnetometer.y,
        normalizedMagnetometer.z,
        normalizedOrientation.y, // Roll
        normalizedOrientation.x, // Pitch
        normalizedOrientation.w // Yaw
      ];

      if (model) {
        const inputTensor = tf.tensor2d([predictionInput], [1, 19], 'float32'); // Tensor with 19 inputs
        const prediction = model.predict(inputTensor);

        // Determine if the prediction indicates stable or unstable
        if (predictedValue < 18) {
          predictionValue = "Stable"; // Display 'Stable' if prediction is less than 18
        } else {
          predictionValue = "Unstable"; // Display 'Unstable' if prediction is 18 or more
        }
      }

      document.getElementById('prediction-result').innerText = predictionValue;
    }
    // }

    // Predict every few seconds
    setInterval(predictWithNormalizedData, 3000); // 3-second interval
  </script>
</body>

</html>