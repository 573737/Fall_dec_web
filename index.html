<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Real-Time Sensor Data with Predictions</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #f0f0f0;
      font-family: Arial, sans-serif;
    }
    #sensorOutput {
      text-align: center;
      border: 1px solid #ccc;
      padding: 20px;
      background-color: white;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>
<body>
  <div id="sensorOutput">
    <h2>Sensor Readings with Predictions</h2>
    <p>Accelerometer (X, Y, Z): <span id="acceleration">N/A</span></p>
    <p>Gyroscope (X, Y, Z): <span id="gyroscope">N/A</span></p>
    <p>Orientation (Alpha, Beta, Gamma): <span id="orientation">N/A</span></p>
    <p>Velocity (X, Y, Z): <span id="velocity">N/A</span></p>
    <p>Magnetometer (X, Y, Z): <span id="magnetometer">N/A</span></p>
    <p>Yaw: <span id="yaw">N/A</span></p>
    <p>Pitch: <span id="pitch">N/A</span></p>
    <p>Roll: <span id="roll">N/A</span></p>
    <p>Prediction: <span id="prediction">N/A</span></p>
  </div>

  <script>
    let model;
    (async () => {
      try {
        model = await tf.loadGraphModel('./model.json');
      } catch (error) {
        console.error("Error loading model:", error);
      }
    })();

    const accelerationElement = document.getElementById("acceleration");
    const gyroscopeElement = document.getElementById("gyroscope");
    const orientationElement = document.getElementById("orientation");
    const velocityElement = document.getElementById("velocity");
    const magnetometerElement = document.getElementById("magnetometer");
    const yawElement = document.getElementById("yaw");
    const pitchElement = document.getElementById("pitch");
    const rollElement = document.getElementById("roll");
    const predictionElement = document.getElementById("prediction");

    let velocity = { x: 0, y: 0, z: 0 };
    let lastTimestamp = null;

    function normalize(value, min, max) {
      if (value === undefined || min >= max) {
        return 0; // Avoid division by zero or undefined errors
      }
      return (value - min) / (max - min);
    }

    function handleDeviceMotion(event) {
      const { acceleration, rotationRate, timeStamp } = event;

      if (acceleration) {
        if (lastTimestamp !== null) {
          const dt = (timeStamp - lastTimestamp) / 1000; // Time difference in seconds
          velocity.x += (acceleration.x ?? 0) * dt;
          velocity.y += (acceleration.y ?? 0) * dt;
          velocity.z += (acceleration.z ?? 0) * dt;
        }

        lastTimestamp = timeStamp;

        accelerationElement.textContent = `
          X: ${acceleration.x?.toFixed(2) ?? 'N/A'},
          Y: ${acceleration.y?.toFixed(2) ?? 'N/A'},
          Z: ${acceleration.z?.toFixed(2) ?? 'N/A'}
        `;

        velocityElement.textContent = `
          X: ${velocity.x.toFixed(2)},
          Y: ${velocity.y.toFixed(2)},
          Z: ${velocity.z.toFixed(2)}
        `;
      }

      if (rotationRate) {
        gyroscopeElement.textContent = `
          X: ${rotationRate.alpha?.toFixed(2) ?? 'N/A'},
          Y: ${rotationRate.beta?.toFixed(2) ?? 'N/A'},
          Z: ${rotationRate.gamma?.toFixed(2) ?? 'N/A'}
        `;
      }
    }

    function handleDeviceOrientation(event) {
      const { alpha, beta, gamma } = event;

      orientationElement.textContent = `
        Alpha: ${alpha?.toFixed(2) ?? 'N/A'},
        Beta: ${beta?.toFixed(2) ?? 'N/A'},
        Gamma: ${gamma?.toFixed(2) ?? 'N/A'}
      `;

      yawElement.textContent = `${alpha?.toFixed(2) ?? 'N/A'}`;
      pitchElement.textContent = `${beta?.toFixed(2) ?? 'N/A'}`;
      rollElement.textContent = `${gamma?.toFixed(2) ?? 'N/A'}`;
    }

    window.addEventListener("devicemotion", handleDeviceMotion);
    window.addEventListener("deviceorientation", handleDeviceOrientation);

    function getNormalizedSensorData() {
      const expectedRanges = {
        velocity: { min: -10, max: 10 },
        orientation: { min: 0, max: 360 },
        acceleration: { min: -10, max: 10 },
        gyroscope: { min: -250, max: 250 },
        magnetometer: { min: -100, max: 100 },
      };

      return [
        normalize(velocity.x, expectedRanges.velocity.min, expectedRanges.velocity.max),
        normalize(velocity.y, expectedRanges.velocity.min, expectedRanges.velocity.max),
        normalize(velocity.z, expectedRanges.velocity.min, expectedRanges.velocity.max),
        normalize(orientationElement.alpha, expectedRanges.orientation.min, expectedRanges.orientation.max),
        normalize(orientationElement.beta, expectedRanges.orientation.min, expectedRanges.orientation.max),
        normalize(orientationElement.gamma, expectedRanges.orientation.min, expectedRanges.orientation.max),
        normalize(gyroscopeElement.alpha, expectedRanges.gyroscope.min, expectedRanges.gyroscope.max),
        normalize(gyroscopeElement.beta, expectedRanges.gyroscope.min, expectedRanges.gyroscope.max),
        normalize(gyroscopeElement.gamma, expectedRanges.gyroscope.min, expectedRanges.gyroscope.max),
        normalize(accelerationElement.x, expectedRanges.acceleration.min, expectedRanges.acceleration.max),
        normalize(accelerationElement.y, expectedRanges.acceleration.min, expectedRanges.acceleration.max),
        normalize(accelerationElement.z, expectedRanges.acceleration.min, expectedRanges.acceleration.max),
        normalize(magnetometerElement.alpha, expectedRanges.magnetometer.min, expectedRanges.magnetometer.max),
        normalize(magnetometerElement.beta, expectedRanges.magnetometer.min, expectedRanges.magnetometer.max),
        normalize(magnetometerElement.gamma, expectedRanges.magnetometer.min, expectedRanges.magnetometer.max),
      ];
    }

    async function makePrediction() {
      if (model) {
        try {
          const sensorData = getNormalizedSensorData();
          const inputTensor = tf.tensor2d([sensorData], [1, sensorData.length], 'float32'); // Create tensor
          const prediction = model.predict(inputTensor); // Make prediction
          const predictedValue = (await prediction.data())[0].toFixed(2); // Get the prediction value

          predictionElement.textContent = predictedValue;
          inputTensor.dispose(); // Dispose of tensor to prevent memory leaks
        } catch (error) {
          console.error("Error during prediction:", error);
          predictionElement.textContent = "Error"; // Display error if something goes wrong
        }
      } else {
        console.warn("Model not loaded");
      }
    }

    // Set interval to make predictions every 3 seconds
    setInterval(makePrediction, 3000);
  </script>
</body>
</html>
