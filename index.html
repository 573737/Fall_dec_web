<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Real-Time Sensor Data with Predictions</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #f0f0f0;
      font-family: Arial, sans-serif;
    }

    #sensorOutput {
      text-align: center;
      border: 1px solid #ccc;
      padding: 20px;
      background-color: white;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    #sensorTable {
      width: 100%;
      border-collapse: collapse;
    }

    #sensorTable th,
    #sensorTable td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: center;
    }

    #sensorTable th {
      background-color: #f2f2f2;
    }
  </style>
</head>

<body>
  <div id="sensorOutput">
    <h2>Sensor Data Table with Predictions</h2>
    <table id="sensorTable">
      <thead>
        <tr>
          <th>Time</th>
          <th>Vel_X</th>
          <th>Vel_Y</th>
          <th>Vel_Z</th>
          <th>Ori_w</th>
          <th>Ori_x</th>
          <th>Ori_y</th>
          <th>Ori_z</th>
          <th>Acc_X</th>
          <th>Acc_Y</th>
          <th>Acc_Z</th>
          <th>Gyr_X</th>
          <th>Gyr_Y</th>
          <th>Gyr_Z</th>
          <th>Mag_X</th>
          <th>Mag_Y</th>
          <th>Mag_Z</th>
          <th>Roll</th>
          <th>Pitch</th>
          <th>Yaw</th>
          <th>Prediction</th>
        </tr>
      </thead>
      <tbody>
        <!-- Rows will be added here -->
      </tbody>
    </table>
  </div>

  <script>
    let model;
    (async () => {
      try {
        model = await tf.loadGraphModel('./model.json');
      } catch (error) {
        console.error("Error loading model:", error);
      }
    })();

    const sensorTableBody = document.getElementById("sensorTable").querySelector("tbody");

    // Initial sensor values
    let velocity = { x: 0, y: 0, z: 0 };
    let orientation = { w: 0, x: 0, y: 0, z: 0 };
    let acceleration = { x: 0, y: 0, z: 0 };
    let gyroscope = { x: 0, y: 0, z: 0 };
    let magnetometer = { x: 0, y: 0, z: 0 };

    let lastTimestamp = null;

    function normalize(value, min, max) {
      if (value === undefined || min >= max) {
        console.error(`Invalid normalization range: min=${min}, max=${max}`);
        return 0;
      }
      return (value - min) / (max - min);
    }

    function addDefault(value, defaultValue) {
      return value === undefined || value === null ? defaultValue : value;
    }

    async function addSensorDataWithPrediction() {
      const newRow = document.createElement("tr");

      const currentTime = new Date().toLocaleTimeString();

      // Define expected sensor ranges and apply range validation
      const expectedRanges = {
        velocity: { min: -10, max: 10 },
        orientation: { min: 0, max: 360 },
        acceleration: { min: -10, max: 10 },
        gyroscope: { min: -250, max: 250 },
        magnetometer: { min: -100, max: 100 },
      };

      const normalizedVelocity = {
        x: normalize(addDefault(velocity.x, 0), expectedRanges.velocity.min, expectedRanges.velocity.max),
        y: normalize(addDefault(velocity.y, 0), expectedRanges.velocity.min, expectedRanges.velocity.max),
        z: normalize(addDefault(velocity.z, 0), expectedRanges.velocity.min, expectedRanges.velocity.max),
      };

      const normalizedOrientation = {
        w: normalize(addDefault(orientation.w, 0), expectedRanges.orientation.min, expectedRanges.orientation.max),
        x: normalize(addDefault(orientation.x, 0), expectedRanges.orientation.min, expectedRanges.orientation.max),
        y: normalize(addDefault(orientation.y, 0), expectedRanges.orientation.min, expectedRanges.orientation.max),
        z: normalize(addDefault(orientation.z, 0), expectedRanges.orientation.min, expectedRanges.orientation.max),
      };

      const normalizedAcceleration = {
        x: normalize(addDefault(acceleration.x, 0), expectedRanges.acceleration.min, expectedRanges.acceleration.max),
        y: normalize(addDefault(acceleration.y, 0), expectedRanges.acceleration.min, expectedRanges.acceleration.max),
        z: normalize(addDefault(acceleration.z, 0), expectedRanges.acceleration.min, expectedRanges.acceleration.max),
      };

      const normalizedGyroscope = {
        x: normalize(addDefault(gyroscope.x, 0), expectedRanges.gyroscope.min, expectedRanges.gyroscope.max),
        y: normalize(addDefault(gyroscope.y, 0), expectedRanges.gyroscope.min, expectedRanges.gyroscope.max),
        z: normalize(addDefault(gyroscope.z, 0), expectedRanges.gyroscope.min, expectedRanges.gyroscope.max),
      };

      const normalizedMagnetometer = {
        x: normalize(addDefault(magnetometer.x, 0), expectedRanges.magnetometer.min, expectedRanges.magnetometer.max),
        y: normalize(addDefault(magnetometer.y, 0), expectedRanges.magnetometer.min, expectedRanges.magnetometer.max),
        z: normalize(addDefault(magnetometer.z, 0), expectedRanges.magnetometer.min, expectedRanges.magnetometer.max),
      };

      const sensorData = [
        normalizedVelocity.x,
        normalizedVelocity.y,
        normalizedVelocity.z,
        normalizedOrientation.w,
        normalizedOrientation.x,
        normalizedOrientation.y,
        normalizedOrientation.z,
        normalizedAcceleration.x,
        normalizedAcceleration.y,
        normalizedAcceleration.z,
        normalizedGyroscope.x,
        normalizedGyroscope.y,
        normalizedGyroscope.z,
        normalizedMagnetometer.x,
        normalizedMagnetometer.y,
        normalizedMagnetometer.z,
        normalizedOrientation.y, // Roll
        normalizedOrientation.x, // Pitch
        normalizedOrientation.w, // Yaw
      ];

      let predictionValue = "N/A";
      if (model) {
        try {
          const inputTensor = tf.tensor2d([sensorData], [1, 19], 'float32');
          const prediction = model.predict(inputTensor);
          predictionValue = (await prediction.data())[0].toFixed(2);
          inputTensor.dispose(); // Ensure proper tensor disposal
        } catch (error) {
          console.error("Error during model prediction:", error);
        }
      }

      newRow.innerHTML = `
        <td>${currentTime}</td>
        <td>${normalizedVelocity.x.toFixed(2)}</td>
        <td>${normalizedVelocity.y.toFixed(2)}</td>
        <td>${normalizedVelocity.z.toFixed(2)}</td>
        <td>${normalizedOrientation.w.toFixed(2)}</td>
        <td>${normalizedOrientation.x.toFixed(2)}</td>
        <td>${normalizedOrientation.y.toFixed(2)}</td>
        <td>${normalizedOrientation.z.toFixed(2)}</td>
        <td>${normalizedAcceleration.x.toFixed(2)}</td>
        <td>${normalizedAcceleration.y.toFixed(2)}</td>
        <td>${normalizedAcceleration.z.toFixed(2)}</td>
        <td>${normalizedGyroscope.x.toFixed(2)}</td>
        <td>${normalizedGyroscope.y.toFixed(2)}</td>
        <td>${normalizedGyroscope.z.toFixed(2)}</td>
        <td>${normalizedMagnetometer.x.toFixed(2)}</td>
        <td>${normalizedMagnetometer.y.toFixed(2)}</td>
        <td>${normalizedMagnetometer.z.toFixed(2)}</td>
        <td>${normalizedOrientation.x.toFixed(2)}</td> 
        <td>${normalizedOrientation.y.toFixed(2)}</td> 
        <td>${normalizedOrientation.w.toFixed(2)}</td> 
        <td>${predictionValue}</td>
      `;

      sensorTableBody.appendChild(newRow);
    }

    window.addEventListener("devicemotion", (event) => {
      const { acceleration, rotationRate, timeStamp } = event;

      if (acceleration) {
        const dt = lastTimestamp ? (timeStamp - lastTimestamp) / 1000 : 0;
        lastTimestamp = timeStamp;

        velocity.x += (acceleration.x ?? 0) * dt;
        velocity.y += (acceleration.y ?? 0) * dt;
        velocity.z += (acceleration.z ?? 0) * dt;

        acceleration.x = acceleration.x ?? 0;
        acceleration.y = acceleration.y ?? 0;
        acceleration.z = acceleration.z ?? 0;
      }

      if (rotationRate) {
        gyroscope.x = rotationRate.alpha ?? 0;
        gyroscope.y = rotationRate.beta ?? 0;
        gyroscope.z = rotationRate.gamma ?? 0;
      }
    });

    window.addEventListener("deviceorientation", (event) => {
      const { alpha, beta, gamma } = event;

      orientation.w = alpha ?? 0;
      orientation.x = beta ?? 0;
      orientation.y = gamma ?? 0;
      orientation.z = alpha ?? 0;
    });

    setInterval(() => {
      addSensorDataWithPrediction();
    }, 3000); // 3-second interval
  </script>
</body>

</html>